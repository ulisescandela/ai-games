<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Hopper 3D</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 30px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.85);
            color: white;
            padding: 40px;
            text-align: center;
            border-radius: 15px;
            display: none;
            border: 4px solid #fff;
            box-shadow: 10px 10px 0 rgba(0,0,0,0.5);
            z-index: 20;
            min-width: 300px;
        }
        button {
            background:#ffcc00; border:none; padding:15px 30px; 
            font-size:20px; font-weight:bold; cursor:pointer; 
            margin-top:20px; font-family: inherit;
            box-shadow: 4px 4px 0 #bbaa00;
            border-radius: 8px;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: translate(4px, 4px); box-shadow: none; }
        button:hover { filter: brightness(1.1); }
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">SCORE: <span id="score">0</span></div>
    
    <div id="game-over">
        <h1 style="margin:0 0 20px 0; font-size: 40px;">SPLAT! üêî</h1>
        <p style="font-size: 24px;">Score: <span id="final-score">0</span></p>
        <div style="display: flex; gap: 20px; justify-content: center;">
            <button onclick="location.reload()">RETRY</button>
            <button onclick="location.href='index.html'" style="background:#ff5555; box-shadow: 4px 4px 0 #aa0000;">EXIT</button>
        </div>
    </div>

    <div class="controls-hint">Use ARROW KEYS or WASD to Move</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const LANE_SIZE = 60;  // Width of world
        const TILE_SIZE = 20;  // Visual scale
        const MOVE_TIME = 0.15; // Seconds to hop

        class Game {
            constructor() {
                this.score = 0;
                this.lanes = [];
                this.currentLane = 0; // Player's logical Z index
                this.playerPos = 0;   // Player's logical X index (0 is center)
                this.isMoving = false;
                this.isDead = false;

                // Setup Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky Blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 300, 900);

                // Isometric Camera
                const aspect = window.innerWidth / window.innerHeight;
                const d = 120; // Zoom level
                this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                this.camera.position.set(100, 100, 100); 
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(this.renderer.domElement);

                // Lighting
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                
                const sun = new THREE.DirectionalLight(0xffffff, 0.9);
                sun.position.set(50, 100, 50);
                sun.castShadow = true;
                sun.shadow.mapSize.width = 2048; 
                sun.shadow.mapSize.height = 2048;
                sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
                sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
                this.scene.add(sun);

                // Player (The Chicken - Voxel Style)
                this.playerGroup = new THREE.Group();
                
                // Body
                const bodyGeo = new THREE.BoxGeometry(10, 10, 10);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White chicken
                this.playerMesh = new THREE.Mesh(bodyGeo, bodyMat);
                this.playerMesh.position.y = 5;
                this.playerMesh.castShadow = true;
                
                // Beak
                const beak = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshStandardMaterial({ color: 0xffaa00 }));
                beak.position.set(0, 6, 6); // Front
                this.playerMesh.add(beak);

                // Comb (Red thing on head)
                const comb = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 6), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                comb.position.set(0, 11, 0);
                this.playerMesh.add(comb);

                // Wings
                const wingGeo = new THREE.BoxGeometry(2, 6, 8);
                const wingMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0 });
                const lWing = new THREE.Mesh(wingGeo, wingMat);
                lWing.position.set(-6, 4, 0);
                const rWing = new THREE.Mesh(wingGeo, wingMat);
                rWing.position.set(6, 4, 0);
                this.playerMesh.add(lWing);
                this.playerMesh.add(rWing);

                this.playerGroup.add(this.playerMesh);
                this.scene.add(this.playerGroup);

                // Init World
                this.initWorld();

                // Events
                window.addEventListener('keydown', (e) => this.onKey(e));
                window.addEventListener('resize', () => {
                   const aspect = window.innerWidth / window.innerHeight;
                   this.camera.left = -d * aspect; this.camera.right = d * aspect;
                   this.camera.top = d; this.camera.bottom = -d;
                   this.camera.updateProjectionMatrix();
                   this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                this.animate();
            }

            initWorld() {
                // Initial Grass area
                for(let i=0; i<8; i++) {
                    this.addLane(0); // 0 = Grass
                }
                // Generate ahead
                for(let i=0; i<30; i++) {
                    this.addLane(this.pickRandomLaneType());
                }
            }

            pickRandomLaneType() {
                // 0: Grass, 1: Road, 2: River
                // Weighted random
                const r = Math.random();
                if (r < 0.35) return 0; // 35% Grass
                if (r < 0.70) return 1; // 35% Road
                return 2;               // 30% River
            }

            addLane(type) {
                const zIndex = this.lanes.length;
                const laneGroup = new THREE.Group();
                laneGroup.position.z = -zIndex * TILE_SIZE; 
                
                let tileColor = 0x7cfc00; // Lawngreen
                let floorY = 0;
                
                if (type === 1) { tileColor = 0x555555; floorY = -1; } // Road
                else if (type === 2) { tileColor = 0x44ccff; floorY = -4; } // River (sunken)
                
                if (this.lanes.length === 0) tileColor = 0x7cfc00; // Start is always green

                // Floor Plane
                const geo = new THREE.BoxGeometry(LANE_SIZE * TILE_SIZE, 10, TILE_SIZE);
                const mat = new THREE.MeshStandardMaterial({ color: tileColor });
                const floor = new THREE.Mesh(geo, mat);
                floor.position.y = -5 + floorY;
                floor.receiveShadow = true;
                laneGroup.add(floor);

                const laneData = {
                    type: type,
                    mesh: laneGroup,
                    obstacles: [],
                    direction: Math.random() > 0.5 ? 1 : -1,
                    speed: (Math.random() * 20) + 15 // units per sec
                };

                // Decor / Obstacles
                if (type === 0 && zIndex > 3) { // Don't block start status
                    // Trees on grass
                    this.addTrees(laneGroup);
                } else if (type === 1) {
                    // Spawn cars
                    this.spawnObstacles(laneData, 1);
                } else if (type === 2) {
                    // Spawn logs
                    this.spawnObstacles(laneData, 2);
                }

                this.scene.add(laneGroup);
                this.lanes.push(laneData);
            }

            addTrees(group) {
                // Determine pattern
                // Randomly place trees
                const count = Math.floor(Math.random() * 5);
                const treeMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                
                const trunkGeo = new THREE.BoxGeometry(6, 10, 6);
                const leavesGeo = new THREE.BoxGeometry(14, 14, 14);

                for(let i=0; i<count; i++) {
                    // Try to avoid center slightly
                    let range = (LANE_SIZE / 2) * TILE_SIZE;
                    let x = (Math.random() * range * 2) - range;
                    
                    // Snap to grid
                    x = Math.round(x / TILE_SIZE) * TILE_SIZE;

                    // Keep path somewhat clear but randomize
                    if (Math.abs(x) < TILE_SIZE * 2 && Math.random() > 0.3) continue;

                    const tree = new THREE.Group();
                    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                    trunk.position.y = 5;
                    const leaves = new THREE.Mesh(leavesGeo, treeMat);
                    leaves.position.y = 15;
                    
                    trunk.castShadow = true; leaves.castShadow = true;
                    tree.add(trunk); tree.add(leaves);
                    tree.position.x = x;
                    
                    // Mark as obstacle
                    // For logic simplicity, we store static obstacles in a simple array or just collision check
                    tree.userData = { isTree: true };

                    group.add(tree);
                    // Add to obstacles list for static collision check? 
                    // To keep it simple, we just check position when hopping
                    group.userData.trees = group.userData.trees || [];
                    group.userData.trees.push(x); 
                }
            }

            spawnObstacles(laneData, type) {
                // Add 2-4 obstacles
                const count = Math.floor(Math.random() * 3) + 2;
                
                // Distribute them evenly to avoid overlap
                const spacing = (LANE_SIZE * TILE_SIZE) / count;

                for(let i=0; i<count; i++) {
                    const obs = new THREE.Group();
                    
                    if (type === 1) { // Car
                        // Random Car Color
                        const colors = [0xff0000, 0x0000ff, 0xffff00, 0xaa00aa];
                        const c = colors[Math.floor(Math.random()*colors.length)];
                        
                        const carBody = new THREE.Mesh(new THREE.BoxGeometry(25, 12, 12), new THREE.MeshStandardMaterial({ color: c }));
                        carBody.position.y = 6;
                        carBody.castShadow = true;
                        obs.add(carBody);
                        
                        // Top
                        const carTop = new THREE.Mesh(new THREE.BoxGeometry(15, 8, 10), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
                        carTop.position.set(0, 14, 0);
                        obs.add(carTop);

                        obs.userData = { width: 25, isLog: false };
                    } else { // Log
                        const logWidth = (Math.random() * 40) + 50; // Longer logs
                        const log = new THREE.Mesh(new THREE.BoxGeometry(logWidth, 8, 14), new THREE.MeshStandardMaterial({ color: 0x8b4513 }));
                        log.position.y = -2; // float low
                        log.receiveShadow = true;
                        obs.add(log);
                        obs.userData = { width: logWidth, isLog: true };
                    }

                    // Spread out
                    obs.position.x = (-LANE_SIZE*TILE_SIZE/2) + (i * spacing) + (Math.random() * 50);
                    laneData.mesh.add(obs);
                    laneData.obstacles.push(obs);
                }
            }

            onKey(e) {
                if (this.isMoving || this.isDead) return;

                let dx = 0;
                let dz = 0;

                if (e.key === 'w' || e.key === 'ArrowUp') dz = -1;
                if (e.key === 's' || e.key === 'ArrowDown') dz = 1;
                if (e.key === 'a' || e.key === 'ArrowLeft') dx = -1;
                if (e.key === 'd' || e.key === 'ArrowRight') dx = 1;

                if (dx !== 0 || dz !== 0) {
                    this.attemptMove(dx, dz);
                }
            }

            attemptMove(dx, dz) {
                // Check if target is blocked by tree
                const targetLaneIdx = this.currentLane - dz; // logic Z increases forward (index)
                const targetX = this.playerPos + dx;

                // Bounds check sides?
                if (Math.abs(targetX) > LANE_SIZE/2) return; // World edge
                if (targetLaneIdx < 0) return; // Cant go back past start

                // Check Trees
                const targetLane = this.lanes[targetLaneIdx];
                if (targetLane && targetLane.mesh.userData.trees) {
                    const trees = targetLane.mesh.userData.trees;
                    // Check if any tree X matches target X (approx)
                    const buffer = TILE_SIZE / 2;
                    const tgtWorldX = targetX * TILE_SIZE;
                    for(let tx of trees) {
                        if (Math.abs(tx - tgtWorldX) < buffer) {
                            // Blocked!
                            // Optional: Shake animation "bonk"
                            return;
                        }
                    }
                }

                this.movePlayer(dx, dz, targetX, targetLaneIdx);
            }

            movePlayer(dx, dz, targetIdxX, targetIdxZ) {
                this.isMoving = true;
                
                // Keep history for logic
                const prevLane = this.currentLane;

                this.playerPos = targetIdxX;
                this.currentLane = targetIdxZ;

                // Calculates world target
                const worldTargetX = this.playerPos * TILE_SIZE;
                const worldTargetZ = -this.currentLane * TILE_SIZE;

                // Rotation
                if (dx > 0) this.playerMesh.rotation.y = -Math.PI/2;
                if (dx < 0) this.playerMesh.rotation.y = Math.PI/2;
                if (dz < 0) this.playerMesh.rotation.y = Math.PI; // Forward
                if (dz > 0) this.playerMesh.rotation.y = 0;

                // Animate Hop
                let startTime = null;
                const startPos = this.playerGroup.position.clone();
                const endPos = new THREE.Vector3(worldTargetX, 0, worldTargetZ); // Y handled by jump
                
                // If moving onto a log (river), Y might be lower, but let's keep player at Y=0 relative to parent usually
                // Oh wait, river floor is LOWER.
                // We'll calculate death/log ride in update loop.

                const animateHop = (time) => {
                    if (!startTime) startTime = time;
                    const elapsed = (time - startTime) / 1000;
                    const t = Math.min(elapsed / MOVE_TIME, 1);

                    // Linear X/Z
                    this.playerGroup.position.lerpVectors(startPos, endPos, t);
                    
                    // Parabolic Y
                    // Height 15
                    this.playerGroup.position.y = (Math.sin(t * Math.PI) * 15);

                    if (t < 1) {
                        requestAnimationFrame(animateHop);
                    } else {
                        this.isMoving = false;
                        this.playerGroup.position.copy(endPos);
                        this.playerGroup.position.y = 0;

                        // Logic Update
                        if (dz === -1) {
                            this.score = Math.max(this.score, this.currentLane);
                            document.getElementById('score').innerText = this.score;
                            
                            // Generate new lane?
                            if (this.lanes.length <= this.currentLane + 30) {
                                this.addLane(this.pickRandomLaneType());
                            }
                        }
                    }
                };
                requestAnimationFrame(animateHop);
            }

            gameOver() {
                if(this.isDead) return;
                this.isDead = true;
                
                // Flatten Chicken
                this.playerGroup.scale.y = 0.1;
                
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('game-over').style.display = 'block';
            }

            checkCollisions(dt) {
                // Get current lane data
                if (this.currentLane < 0) return; 

                const lane = this.lanes[this.currentLane];
                if (!lane) return;

                const playerWorldPos = this.playerGroup.position;
                
                let onLog = false;
                let logSpeed = 0;

                // Check logic based on Lane Type
                if (lane.type === 2) {
                    // Start assuming Death (Water)
                    onLog = false;
                }

                if (lane.obstacles.length > 0) {
                    for (let obs of lane.obstacles) {
                        const obsWorldX = obs.position.x; 
                        const obsWidth = obs.userData.width;

                        // Check overlap
                        const dist = Math.abs(playerWorldPos.x - obsWorldX);
                        const collisionDist = (10/2) + (obsWidth/2) - 4; // Forgiving

                        if (dist < collisionDist) {
                            if (lane.type === 1) {
                                // Hit by CAR -> SPLAT
                                if (!this.isMoving) this.gameOver(); // Only die if hit while standing? Or hopping too?
                                // Actually cars kill you anytime
                                this.gameOver();
                            } else if (lane.type === 2) {
                                // On LOG
                                onLog = true;
                                logSpeed = lane.direction * lane.speed;
                            }
                        }
                    }
                }

                if (lane.type === 2) {
                    // River logic
                    if (onLog) {
                        if (!this.isMoving) {
                            // Ride the log
                            this.playerGroup.position.x += logSpeed * dt;
                            // Update logical pos roughly to prevent drifting off grid too confusingly
                            // But Crossy Road allows drift.
                            
                            // World Wrap for Player if they ride off screen?
                            // Usually you just die if you hit side of screen
                        }
                    } else {
                        // In water!
                        if (!this.isMoving) { // While hopping we are "above" water
                            // SPLASH
                            if (this.playerGroup.position.y > -2) {
                                this.playerGroup.position.y -= 50 * dt; // Sink
                            } else {
                                this.gameOver();
                            }
                        }
                    }
                }
                
                // Side limits
                if (Math.abs(this.playerGroup.position.x) > (LANE_SIZE*TILE_SIZE/2) + 20) {
                    this.gameOver(); // Fell off world
                }
            }

            update(time, dt) {
                if (this.isDead) return;

                // Move Obstacles
                this.lanes.forEach(lane => {
                    if (lane.obstacles.length > 0) {
                        lane.obstacles.forEach(obs => {
                            obs.position.x += lane.direction * lane.speed * dt;
                            
                            // Loop around
                            const limit = (LANE_SIZE * TILE_SIZE) / 2 + 100;
                            if (obs.position.x > limit) obs.position.x = -limit;
                            if (obs.position.x < -limit) obs.position.x = limit;
                        });
                    }
                });

                // Camera Follow (Smooth)
                // Target: Player + Offset
                // Center camera on X? Or follow X?
                const targetZ = this.playerGroup.position.z + 100;
                // Follow X loosely
                const targetX = this.playerGroup.position.x + 100;

                this.camera.position.z += (targetZ - this.camera.position.z) * 5 * dt;
                this.camera.position.x += (targetX - this.camera.position.x) * 2 * dt;
                
                this.checkCollisions(dt);
            }

            animate(time) {
                requestAnimationFrame((t) => this.animate(t));
                
                const dt = this.clock ? this.clock.getDelta() : 0.016;
                if (!this.clock) this.clock = new THREE.Clock();

                // Cap dt for stability
                const safeDt = Math.min(dt, 0.05);

                this.update(time, safeDt);
                this.renderer.render(this.scene, this.camera);
            }
        }

        new Game();

    </script>
</body>
</html>