<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mob Control V2 - Humanoides y Disparos</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #score-board {
            text-align: center;
            padding-top: 40px;
            color: white;
            text-shadow: 0 4px 5px rgba(0,0,0,0.8);
        }

        #army-count { font-size: 3.5rem; font-weight: 900; color: #4facfe; }
        #label { font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px; }

        #tutorial {
            position: absolute;
            bottom: 20%; width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.8);
            font-size: 1.2rem;
            animation: fadeOut 3s forwards;
            animation-delay: 2s;
        }

        #game-over {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            color: white;
            z-index: 10;
        }

        button {
            background: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);
            border: none;
            padding: 15px 40px;
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">
            <div id="army-count">1</div>
            <div id="label">Soldados</div>
        </div>
        <div id="tutorial">Arrastra para moverte • Dispara automáticamente</div>
    </div>

    <div id="game-over">
        <h1 style="font-size: 3rem; margin-bottom: 10px;">¡DERROTADO!</h1>
        <p style="margin-bottom: 30px; font-size: 1.2rem;">Tu ejército ha caído.</p>
        <button onclick="resetGame()">JUGAR DE NUEVO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer;
        let road;
        let clock = new THREE.Clock();
        
        // Grupos y Arrays
        let playerGroup, enemiesGroup, bulletsGroup, gatesGroup;
        let soldiers = []; // Array visual de soldados aliados
        let enemies = [];  // Array visual de enemigos
        let bullets = [];
        let gates = [];

        // Lógica de Juego
        let gameActive = true;
        let armyCount = 1;
        let baseSpeed = 0.4;
        let spawnTimer = 0;
        let shootTimer = 0;
        
        // Input
        let targetX = 0;

        // Modelos base (para clonar y mejorar rendimiento)
        let blueSoldierProto, redSoldierProto;

        init();
        animate();

        function init() {
            // Setup Básico
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 20, 50);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 0, -5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Luces
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Contenedores
            playerGroup = new THREE.Group();
            scene.add(playerGroup);

            enemiesGroup = new THREE.Group();
            scene.add(enemiesGroup);

            bulletsGroup = new THREE.Group();
            scene.add(bulletsGroup);

            gatesGroup = new THREE.Group();
            scene.add(gatesGroup);

            // Crear Suelo
            createRoad();

            // Preparar Modelos (Prototipos para clonar)
            blueSoldierProto = createHumanoidModel(0x007bff); // Azul
            redSoldierProto = createHumanoidModel(0xff0000);  // Rojo

            // Iniciar jugador
            updateArmyVisuals();

            // Eventos
            document.addEventListener('mousemove', onMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('resize', onResize);
        }

        // --- CREACIÓN DE MODELOS (HUMANOIDES) ---
        function createHumanoidModel(colorHex) {
            const group = new THREE.Group();

            // Materiales compartidos
            const bodyMat = new THREE.MeshLambertMaterial({ color: colorHex });
            const skinMat = new THREE.MeshLambertMaterial({ color: 0xffccaa }); // Piel
            const gunMat = new THREE.MeshLambertMaterial({ color: 0x333333 }); // Arma gris

            // Cuerpo
            const bodyGeo = new THREE.BoxGeometry(0.5, 0.6, 0.3);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.3;
            body.castShadow = true;
            group.add(body);

            // Cabeza
            const headGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 0.75;
            group.add(head);

            // Arma (Cilindro simple)
            const gunGeo = new THREE.BoxGeometry(0.1, 0.1, 0.6);
            const gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0.2, 0.4, 0.3);
            group.add(gun);

            return group;
        }

        function createRoad() {
            const geo = new THREE.PlaneGeometry(14, 200);
            const mat = new THREE.MeshPhongMaterial({ color: 0x2a2a2a });
            road = new THREE.Mesh(geo, mat);
            road.rotation.x = -Math.PI / 2;
            road.position.z = -50;
            road.receiveShadow = true;
            scene.add(road);
            
            // Rejilla visual
            const grid = new THREE.GridHelper(14, 7, 0x444444, 0x444444);
            grid.position.z = -50;
            grid.scale.z = 10;
            scene.add(grid);
        }

        // --- ACTUALIZACIÓN VISUAL DEL EJÉRCITO ---
        function updateArmyVisuals() {
            // Lógica para no saturar: 
            // Mostramos máximo 40 muñecos visuales, aunque tengas 1000 en el contador.
            const visualCount = Math.min(Math.max(armyCount, 1), 40);
            
            // Si necesitamos más, agregamos
            while (soldiers.length < visualCount) {
                const soldier = blueSoldierProto.clone();
                // Posición aleatoria en formación
                placeSoldierInFormation(soldier);
                playerGroup.add(soldier);
                soldiers.push({ mesh: soldier, offset: soldier.position.clone() });
            }

            // Si sobran, quitamos (cuando restas o mueren)
            while (soldiers.length > visualCount) {
                const unit = soldiers.pop();
                playerGroup.remove(unit.mesh);
            }

            document.getElementById('army-count').innerText = Math.floor(armyCount);
        }

        function placeSoldierInFormation(soldierMesh) {
            // Formación en cuña o círculo disperso
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 2;
            soldierMesh.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
        }

        // --- SPAWNING (ENEMIGOS Y PUERTAS) ---
        function spawnElements() {
            spawnTimer++;

            // Spawner de Enemigos (Rojos)
            if (spawnTimer % 150 === 0) { // Cada cierto tiempo
                spawnEnemyWave();
            }

            // Spawner de Puertas (Matemáticas)
            if (spawnTimer % 220 === 0) {
                spawnGatePair();
            }
        }

        function spawnEnemyWave() {
            // Crea un grupo de 3 a 8 enemigos
            const count = Math.floor(Math.random() * 5) + 3;
            const laneX = (Math.random() * 8) - 4; // Posición X aleatoria
            
            for(let i=0; i<count; i++) {
                const enemyMesh = redSoldierProto.clone();
                // Formación pequeña enemiga
                const xOff = (Math.random() - 0.5) * 2;
                const zOff = (Math.random() - 0.5) * 2;
                
                enemyMesh.position.set(laneX + xOff, 0, -40 + zOff); // Aparecen lejos (-40 z)
                
                enemiesGroup.add(enemyMesh);
                enemies.push({ mesh: enemyMesh, active: true });
            }
        }

        function spawnGatePair() {
            const zPos = -50;
            const ops = [
                { val: 5, label: '+5', type: 'add', color: '#007bff' },
                { val: 10, label: '+10', type: 'add', color: '#007bff' },
                { val: 2, label: 'x2', type: 'mult', color: '#007bff' },
                { val: 10, label: '-10', type: 'sub', color: '#dc3545' },
                { val: 2, label: '/2', type: 'div', color: '#dc3545' }
            ];

            const opLeft = ops[Math.floor(Math.random() * ops.length)];
            const opRight = ops[Math.floor(Math.random() * ops.length)];

            createGate(-3, zPos, opLeft);
            createGate(3, zPos, opRight);
        }

        function createGate(x, z, op) {
            // Canvas para texto
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = op.color;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(0,0,256,128);
            ctx.globalAlpha = 1;
            ctx.fillStyle = "white";
            ctx.font = "bold 60px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(op.label, 128, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            const geo = new THREE.PlaneGeometry(5, 3);
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 1.5, z);
            
            mesh.op = op; // Guardar datos
            gatesGroup.add(mesh);
            gates.push(mesh);
        }

        // --- DISPAROS ---
        function shoot() {
            shootTimer++;
            // Cadencia de disparo depende de cuántos soldados tengas (más soldados = más disparos)
            // Topeamos la velocidad para no laggear
            const fireRate = Math.max(5, 40 - Math.floor(armyCount / 2)); 
            
            if (shootTimer > fireRate) {
                shootTimer = 0;
                // Disparo desde el centro del grupo
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 4, 4), 
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                bullet.position.copy(playerGroup.position);
                bullet.position.y = 0.5;
                // Pequeña dispersión
                bullet.position.x += (Math.random() - 0.5) * 2; 

                bulletsGroup.add(bullet);
                bullets.push(bullet);
            }
        }

        // --- BUCLE PRINCIPAL (LÓGICA) ---
        function update() {
            if (!gameActive) return;

            const delta = clock.getDelta();

            // 1. Movimiento del Jugador (Lateral suavizado)
            playerGroup.position.x += (targetX - playerGroup.position.x) * 0.1;
            playerGroup.position.x = Math.max(-5, Math.min(5, playerGroup.position.x));

            // Simulación de avance: En realidad traemos el mundo hacia el jugador (Eje Z)
            // Movemos enemigos y puertas hacia Z positivo (hacia la cámara)
            const speed = baseSpeed;

            // Mover Enemigos
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                // Los enemigos avanzan hacia el jugador
                e.mesh.position.z += speed * 1.2; // Un poco más rápido que el escenario
                
                // Animación simple de caminar (saltito)
                e.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.01 + e.mesh.position.x)) * 0.3;

                // Colisión: Enemigo vs Jugador
                if (e.mesh.position.z > playerGroup.position.z - 1) {
                    // Distancia lateral cercana
                    if (Math.abs(e.mesh.position.x - playerGroup.position.x) < 2.5) {
                        // Impacto!
                        createExplosion(e.mesh.position, 0xff0000);
                        enemiesGroup.remove(e.mesh);
                        enemies.splice(i, 1);
                        
                        // Pierdes soldados
                        armyCount--;
                        updateArmyVisuals();
                        if(armyCount <= 0) gameOver();
                    }
                }
                
                // Limpieza si pasan de largo
                if (e.mesh.position.z > 10) {
                    enemiesGroup.remove(e.mesh);
                    enemies.splice(i, 1);
                }
            }

            // Mover Puertas
            for (let i = gates.length - 1; i >= 0; i--) {
                const g = gates[i];
                g.position.z += speed;

                // Colisión con Puerta
                if (g.position.z > playerGroup.position.z - 0.5 && g.position.z < playerGroup.position.z + 0.5) {
                    if (Math.abs(g.position.x - playerGroup.position.x) < 3) {
                        applyMath(g.op);
                        gatesGroup.remove(g);
                        gates.splice(i, 1);
                    }
                }
                // Limpieza
                if (g.position.z > 10) {
                    gatesGroup.remove(g);
                    gates.splice(i, 1);
                }
            }

            // Mover Balas
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.position.z -= 0.5; // Las balas viajan hacia el fondo (-Z)

                let hit = false;
                // Checar colisión con enemigos
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    let dist = b.position.distanceTo(e.mesh.position);
                    if (dist < 0.8) {
                        // Enemigo muerto
                        createExplosion(e.mesh.position, 0xff0000);
                        enemiesGroup.remove(e.mesh);
                        enemies.splice(j, 1);
                        hit = true;
                        break; 
                    }
                }

                if (hit || b.position.z < -60) {
                    bulletsGroup.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // Animar soldados del jugador (Caminar)
            soldiers.forEach((s, idx) => {
                s.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.01 + idx)) * 0.2;
            });

            // Auto disparar
            shoot();

            // Spawneo continuo
            spawnElements();
        }

        function applyMath(op) {
            if(op.type === 'add') armyCount += op.val;
            if(op.type === 'sub') armyCount -= op.val;
            if(op.type === 'mult') armyCount *= op.val;
            if(op.type === 'div') armyCount = Math.floor(armyCount / op.val);
            
            // Efecto visual de "POP"
            playerGroup.scale.set(1.2, 1.2, 1.2);
            setTimeout(() => playerGroup.scale.set(1,1,1), 100);

            updateArmyVisuals();
            if(armyCount <= 0) gameOver();
        }

        function createExplosion(pos, color) {
            // Efecto de partículas muy simple
            // (Para un one-shot simple no implementaremos sistema de partículas complejo)
            // Pero podríamos hacer un flash de luz o sonido
        }

        // --- INPUT ---
        function onMove(e) {
            targetX = ((e.clientX / window.innerWidth) * 2 - 1) * 6;
        }
        function onTouchMove(e) {
            e.preventDefault();
            targetX = ((e.touches[0].clientX / window.innerWidth) * 2 - 1) * 6;
        }
        function onResize(){
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'flex';
        }

        function resetGame() {
            armyCount = 1;
            enemies.forEach(e => enemiesGroup.remove(e.mesh));
            enemies = [];
            bullets.forEach(b => bulletsGroup.remove(b));
            bullets = [];
            gates.forEach(g => gatesGroup.remove(g));
            gates = [];
            
            gameActive = true;
            document.getElementById('game-over').style.display = 'none';
            updateArmyVisuals();
        }

        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>